---
title: "Phanerozoic fossil occurrences and their geological context"
author: Peter Smits
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    theme: paper
    toc: true
    toc_depth: 2
    toc_float: true
    fig_width: 10
    fig_height: 6
    df_print: paged
    code_folding: show
---

# Introduction

The fossil record is full of gaps -- it fails to record the environment more often than it succeeds. My metaphor of choice has been a busted grabbing claw.

Inconsistent sampling of a taxon over time is a common type of gap in the fossil record. For example, a fossil of species X is observed in time $t_{1}$ and time $t_{3}$ but not at time $t_{2}$. The occurrence record of species X can then be labeled a ["Lazarus taxon"](https://en.wikipedia.org/wiki/Lazarus_taxon) -- it was believed gone but it reappeared. This type of occurrence record applies to any size gap and can be generalised to mean any species occurrence record where that species is observed at times $t_{n}$ and $t_{m}$ where $n$ and $m$ are nonconsecutive time intervals and there are no occurrences between times $n$ and $m$.

The Lazarus effect is when multiple Lazarus taxa share their gaps and observation times. When multiple Lazarus taxa appear in the same interval, this is called a Lazarus effect. For example, species X, Y, and Z are observed at times $t_{1}$ and $t_{3}$, but are not observed at time $t_{2}$. 

The Lazarus effect after a mass extinction could be caused by a change to the quality of the stratigraphic record. If there are fewer rocks with fossils in then, it is harder to observe fossils.

Another potential cause of the Lazarus effect after mass extinctions is mass rarity -- if a species is rarer on the ground, then it is much less likely to be sampled. All mass extinctions are biotic crises -- the environment is completely reshaped through loss of key interactors. We might expect then that species abundance decreases universally. Until abundance recovers, the probability of sampling any species is too low. Thus, we might then expect a Lazarus effect in an time interval after a mass extinction.

So what is contributing more to simultaneous gaps in the occurrence records of multiple species? Is it the inconsistent quality of the fossil record or is it the rarity of taxa? 

To start getting a better handle on how these two potential causes may contribute to gaps in the fossil record, I'm going to exploring two databases: [Macrostrat](https://macrostrat.org/) and the [Paleobiology database (PBDB)](https://paleobiodb.org/#/). Macrostrat is a database of all North American geological units, while the PBDB is a database of fossil occurrences across the entire globe and for the whole Phanerozoic. The PBDB is a community project and is an incomplete record of all known fossil occurrences, it is the single largest database of its kind and is the discipline standard for global occurrence data.


# Loading data

Macrostrat geological units have metadata that includes PBDB collections unique identifiers, but the PBDB includes no information about which Macrostrat units are associated with PBDB occurrences. This frustration is probably cased by the PBDB being older than Macrostrat.


Step 0 is loading some useful packages for loading and cleaning data.

```{r packages, message = FALSE, warning = FALSE, results = 'hide'}

library(pacman)

p_load(here, janitor, tibble, readr, magrittr, dplyr, 
       tidyr, purrr, glue, stringr, furrr,
       ggplot2, scales, grid, ggridges, viridis, ggrepel,
       compositions, 
       arm, brms)

library(notfossil)
# devtools::load_all()

```

There are also several useful constants that will appear throughout the next few sections.

```{r constants}

plan(multiprocess)

theme_set(theme_bw(base_size = 20))

# useful constants
shelly <- c('Brachiopoda', 'Anthozoa', 'Trilobita', 
            'Bivalvia', 'Gastropoda')#, 'Cephalopoda')
temp_range <- c(541, 0)                # phanerozoic
big_5 <- c(443.8, 358.9, 251.9, 201.3, 66)

```

## Macrostrat geological units

The first set is pulling the relevant raw data from Macrostrat. I want geological units from the entire Phanerozoic (the last 541 million years). In Macrostrat, a geological unit is defined as a gap-bounded litho-stratigraphic interval -- an association of rocks in sequence that is distinct from those rocks above and below.

Macrostrat has a [minimally documented API](https://macrostrat.org/api), so I'll write out a call for all geological units. I believe the underlying structure is a GeoJSON database, but there are a lot of different output options. I'm using a CSV output because I'm interested in lithologic (rock type) and stratigraphic (rock position in time/space) information, but I'm not interested in the spatial/map objects available for each geological unit.

```{r macro_unit, cache = TRUE, message = FALSE, warning = FALSE, results = 'hide'}

unit_url <- glue('https://macrostrat.org/api/v2/units?',
                 'interval_name=Phanerozoic&response=long&format=csv')
unit_data <- read_csv(unit_url)

```
```{r macro_unit_print}

print(unit_data)

```

## Macrostrat fossil collections

`unit_data` is a tibble where each row is a [geological unit](https://macrostrat.org/api/units). Each unit has a unique identifier `unit_id`. Each unit also two fields, `pbdb_collections` and `pbdb_occurrences`, which are counts of the number of collections or occurrences, respectively, that are associated with that unit. Collections are groups of occurrences that are associated, frequently because they were recorded in the same paper. A collection has one or more occurrences associated with it. 

Frustratingly, the information on *which* collections or occurrences are associated with that unit is missing from the `units` table. Instead, I need to write a query to the `fossils` table in Macrostrat to get the relevant information. Using the `unit_id` key from the `units` table, I'll write a quick query for all fossil occurrence information from any unit that has at least 1 occurrence. With a tiny bit of massaging, these units can be entered into a second Macrostrat API call.

```{r macro_collect, cache = TRUE, message = FALSE, warning = FALSE, results = 'hide'}

unit_w_fossils <- 
  unit_data %>%
  filter(pbdb_occurrences > 0) %>%
  dplyr::select(unit_id) %>%
  pull() %>%
  glue_collapse(., sep = ',')

collect_url <- glue('https://macrostrat.org/api/v2/fossils?unit_id=',
                    '{unit_w_fossils}',
                    '&response=long&format=csv')

collect_data <- read_csv(collect_url)

```

```{r macro_collect_print}

print(collect_data)

```

## PBDB occurrences

The `collect_data` tibble has all the necessary information to recover fossil occurrence information from the PBDB. The column `cltn_id` has the unique identifier for the PBDB collections associated with each geological unit (`unit_id`). We can extract and massage the `cltn_id` column into a vector we can pass to the [better documented PBDB API](https://paleobiodb.org/data1.2/), making a call for an [occurrence list](https://paleobiodb.org/data1.2/occs/list_doc.html). The resulting tibble has a row for every fossil occurrence found in collections made from geological units in our Macrostrat data.

One of the issues we face here is that the number of collections is *so large* that the URI is so long that it throws a [HTTP error 414](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/414). So I'm going to chop the query up and then combine the results.

```{r pbdb_occurrence, cache = TRUE, message = FALSE, warning = FALSE, results = 'hide'}

pbdb_collections <- 
  collect_data %>%
  dplyr::select(cltn_id) %>%
  filter(!duplicated(cltn_id)) %>%
  mutate(chunk = ntile(n = 20)) %>%
  group_by(chunk) %>%
  group_map(., ~ .x %>% 
            dplyr::select(cltn_id) %>% 
            pull %>% 
            glue_collapse(., sep = ','))

# pbdb servers get overwhelmed easily, so not parallel
pbdb_urls <- 
  map(pbdb_collections, 
      ~ glue('https://paleobiodb.org/data1.2/occs/list.txt?coll_id=',
             '{.x}',
             '&show=full'))

pbdb_data <- future_map(pbdb_urls, ~ read_csv(.x)) %>%
  reduce(., rbind)                     
# type inference issues from read_csv prevent union ;_;

```
```{r pbdb_occurrences_print}

print(pbdb_data)

```

## Joining Macrostrat and PBDB

Now that that's out of the way, let's start getting out data into shape. An obvious first step is connect the Macrostrat units table to the fossils table. 

There are multiple collections occurrences per unit, so I'll add all the appropriate unit information to each fossil collection. I'm not worrying about units that lack fossils (yet), hence the left join. 

```{r join_macrostrat}

collect_unit <- left_join(x = collect_data, y = unit_data, 
                          by = c('unit_id', 'col_id', 't_age', 'b_age')) %>%
  dplyr::select(-(genus_no:taxon_no), -refs.y) # redundant/unnecessary

```

This gives a single table with all fossil collections associated with their geological information (lithology, age, etc.) The next step is associating the geological context of each collection with the individual occurrences within that collection. I'm only caring about occurrences recorded in the PBDB -- they have the most information -- hence the left join. 

```{r join_pbdb}

occur_collect <- 
  pbdb_data %>%
  left_join(., collect_unit, by = c('collection_no' = 'cltn_id')) %>%
  mutate(occur_mid_ma = (max_ma + min_ma) / 2,
         unit_mid_ma = (t_age + b_age) / 2)

```


## Filter by occurrence age and taxonomic group

A big issue is that these occurrences from all over time, not the Phanerozoic. This problem due to geological units not being restricted to a particular time interval. A unit can range through, into, or out of our target temporal range. So, while we might have only queried Phanerozoic units, those units can exist both before and during the Phanerozoic.

To overcome this and focus only on fossil occurrences from Phanerozoic, I filtering down to only those occurrences who's mid-point age is within `temp_range`.

In paleobiology we also tend to focus on the record of shelly, skeletonized species like bivalves, gastropods, and brachiopods. These taxa preserve more readily than soft-bodied taxa like most cnidarians and polychetes. I'm going to restrict our fossil occurrences to those from the "shelly" groups.

```{r misc_filters}

occur_collect %<>%
  mutate(phylum_shelly = ifelse(phylum %in% shelly, phylum, NA),
         class_shelly = ifelse(class %in% shelly, class, NA),
         shelly = coalesce(phylum_shelly, class_shelly)) %>%
  filter(between(occur_mid_ma, temp_range[2], temp_range[1]),
         !(is.na(shelly)),
         !(is.na(genus)))

```



## Binning occurrences

The fossil record is a discrete recording of continuous time which creates all kinds of problems. Additionally, paleo-time is more of a range than an instantaneous value. Binning out data helps alleviate this -- it requires us to define a temporal width for each bin. There are two ways to do this: predetermine how many bins you want, or pick an (arbitrary) value. Luckily I've written a function that can do both: `bin_ages()`.

I want to compare multiple arbitrary bin widths to pick whatever feels "smoothest". Sadly, I have trouble defining this algorithmically, but the general idea is to have as many bins as possible to have 1+ fossils and there are as few bins as possible with 0 fossils. Common bin widths include 1, 2, 5, and 10 million years, but I'm gonna look at a few more. 

```{r compare_bin, fig.width = 10, fig.height = 10}

bin_test <- 
  occur_collect %>%
  transmute(bin_01 = bin_ages(occur_mid_ma, by = 1, age = TRUE),
            bin_02 = bin_ages(occur_mid_ma, by = 2, age = TRUE),
            bin_025 = bin_ages(occur_mid_ma, by = 2.5, age = TRUE),
            bin_05 = bin_ages(occur_mid_ma, by = 5, age = TRUE),
            bin_10 = bin_ages(occur_mid_ma, by = 10, age = TRUE)) %>%
  gather(key = key, value = value) 

# how many empty bins
empty_bin <- function(x, by = 1) {
  all_bins <- seq(from = min(x), to = max(x), by = by)
  missing_bins <- !(all_bins %in% x)
  missing_bins
}

bin_test %>%
  group_by(key) %>%
  nest() %>%
  mutate(n_bin = map2(data, c(1, 2, 2.5, 5, 10),
                      ~ length(seq(from = min(.x$value),
                                   to = max(.x$value),
                                   by = .y))),
         n_empty = map2(data, c(1, 2, 2.5, 5, 10), 
                        ~ sum(empty_bin(.x$value, .y)))) %>%
  dplyr::select(-data) %>%
  unnest() %>%
  print()

bin_test %>%
  ggplot(aes(x = value)) +
  geom_bar(position = 'dodge') +
  facet_wrap(~ key, ncol = 1) +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 10)) 

```

For a record this long, a coarser bin size is totally fine. With only 1 empty bin, a bin width of 5 million years seems fine.

Another wrinkle is that it is nice to have the Big 5 mass extinctions act as boundaries for these temporal bins. A solution to this desire is the split the data by the big 5 mass extinctions, bin those segments as per usual, and then recombine. This means not all of our bins will be identical in actual geological time -- this is the price we pay.


```{r bin_occurrences}

#occur_collect %<>%
#  mutate(bin_time = bin_ages(occur_mid_ma, by = 5, age = TRUE),
#         bin_num = bin_ages(occur_mid_ma, by = 5, age = FALSE))

intervals <- 
  c(temp_range[1], 
    big_5, 
    temp_range[2])

tops <- intervals[-length(intervals)]  # older values
bots <- intervals[-1]                  # younger values

occur_collect <- 
  map2(bots, tops, 
       ~ occur_collect %>%
         filter(between(occur_mid_ma, left = .x, right = .y)) %>%
         mutate(bin_time = bin_ages(occur_mid_ma, by = 5, age = TRUE),
                bin_time = if_else(bin_time == max(bin_time), 
                                   .y, bin_time))) %>%
  reduce(., rbind)

# add in rank order of time bins
time_rank <- 
  tibble(bin_time = unique(occur_collect$bin_time),
         bin_num = rank(unique(occur_collect$bin_time)))

occur_collect <- 
  left_join(occur_collect, time_rank, by = 'bin_time')

```


# Sanity checks and exploring 

Now that's I've cleaned up the data a bunch, I'm going to explore some of the patterns in the data. I'm interested in how occurrence changes over time, when multiple last occurrences are in the same time bin, and geological unit lithological composition.

Something important to review now is what exactly our data represents. `occur_collect` is a tibble of fossil occurrences from North American recorded in the PBDB that appear in geological units recorded in Macrostrat. Opportunistic sampling at its best.


## Fossils over time

I'm going to start by looking at the fossils over time. Are there time intervals with a high number of observations? Are there major shifts in the relative diversity of the taxonomic groups?

First, let's explore occurrences over time. Let's look at the raw counts of PBDB occurrences for each time bin by taxonomic group, and the relative abundance of the shelly taxonomic groups over time. 

I'll even include lines representing the [big 5 mass extinctions](https://en.wikipedia.org/wiki/Extinction_event).

The issue here is that there are multiple intervals where some taxonomic groups are not observed. A lot of `geom_*()` functions *really* don't like this. So I have to do some filling.

```{r vis_fossil}

# what bins exist
bins_all <- 
  occur_collect %>%
  dplyr::select(bin_time) %>%
  pull() %>%
  unique() %>%
  sort()

# what bins are missing from each 
bins_missing <- 
  occur_collect %>%
  arrange(shelly) %>%
  group_by(shelly) %>%
  group_map(~ bins_all[!(bins_all %in% .x$bin_time)])

# which temporal bins are 0s
bins_fill <- 
  tibble(shelly = sort(shelly),
         bin_time = bins_missing,
         n = 0) %>%
  unnest()

occur_count <- 
  occur_collect %>%
  group_by(shelly, bin_time) %>%
  count() %>%
  union(., bins_fill)

# now make the plot of interest
occur_count %>%
  ggplot(aes(x = bin_time, y = n, fill = shelly)) +
  geom_area() +
  geom_vline(data = tibble(x = big_5),
             mapping = aes(xintercept = x),
             size = 1.5,
             linetype = 'dashed') +
  scale_fill_viridis(discrete = TRUE) +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 10)) +
  labs(x = 'Time (Mya)', y = 'Observations', fill = 'Taxa')

occur_count %>%
  ggplot(aes(x = bin_time, y = n, fill = shelly)) +
  geom_area(position = 'fill') +
  geom_vline(data = tibble(x = big_5),
             mapping = aes(xintercept = x),
             size = 1.5,
             linetype = 'dashed') +
  scale_fill_viridis(discrete = TRUE) +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 10)) +
  labs(x = 'Time (Mya)', y = 'Relative observations', fill = 'Taxa')

```

Visually, there are three major "phases": Trilobites --> Brachiopods --> Bivalves + Gastropods. [Sepkoski demonstrated this way back in the early 80s](https://www.jstor.org/stable/2400639). So, these results are not surprising and are a sanity check -- very good! 

However we have a glaring issue: raw occurrence abundance counts can be misleading for fossil data. If we are barely recording which species were present, we certainly are getting a biased picture of their abundances. Let's redo both of the above graphs this time looking at diversity. Diversity here is the number of unique taxa present at a given time. For paleodata, we tend to privilege either species or genera as are taxonomic levels of choice, with a particular emphasis on genera because identifying species from partial material is very difficult.  

Importantly, this measure of "diversity" is the count of unique species occurrences for that time bin. This measure ignores range-through taxon and makes no effort to account for differences in sampling probability over time or between taxa. Here, diversity is a raw count.

```{r vis_fossil_unique}

occur_genera <- 
  occur_collect %>%
  group_by(shelly, bin_time) %>%
  filter(!duplicated(genus)) %>%
  count() %>%
  union(., bins_fill)

occur_genera %>%
  ggplot(aes(x = bin_time, y = n, fill = shelly)) +
  geom_area() +
  geom_vline(data = tibble(x = big_5),
             mapping = aes(xintercept = x),
             size = 1.5,
             linetype = 'dashed') +
  scale_fill_viridis(discrete = TRUE) +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 10)) +
  labs(x = 'Time (Mya)', y = 'Diversity (genera)', fill = 'Taxa')

occur_genera %>%
  ggplot(aes(x = bin_time, y = n, fill = shelly)) +
  geom_area(position = 'fill') +
  geom_vline(data = tibble(x = big_5),
             mapping = aes(xintercept = x),
             size = 1.5,
             linetype = 'dashed') +
  scale_fill_viridis(discrete = TRUE) +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 10)) +
  labs(x = 'Time (Mya)', y = 'Relative Diversity (genera)', fill = 'Taxa')

```

Pretty much the same. Cool. Our fossil record resemble a pattern that most paleobiologists would consider "normal". That North American has a similar fossil record to what we'd expect globally isn't too surprising -- most fossil occurrences in the PBDB are from North America because it is well sampled and a lot of literature involves the North American fossil record.



## Lithology over time

Now for some exploration of the geological units from Macrostrat. Remember, these are geological units from North America. Also, many units span multiple time bins which creates a nonindependence in our data because we've binned by fossil occurrences. Macrostrat data does have enough information to divide geological units as they are the smallest unit of observation in that data base (unit < package < column).

For each geological unit there is a short lithological description. Each lithological description can have multiple parts which are given a percent of total composition. Here is an example:

```{r ex_lithology}

occur_collect$lith[1]

```

Lucky for me, these descriptions have a very regular form which makes extracting important text information surprisingly easy.

There are a lot of potential issues when processing lithological descriptions. For example:

- lots of words that appear only once
- similar word but different part of speech
- descriptions are identical except for small modified ("black shale siliciclastic" vs "red shale siliciclastic")

All of these problems mean I have to simplify these descriptions. 

A basic way of dividing lithologies is simply siliciclsatic vs carbonate. Unfortunately, this comparison is not truly binary as mixed-sediments are possible. Additionally, I might be able to extract better information that "siliciclastic" from our natural language descriptions. With this in mind, I've written a function (`simplify_lithology()`) to simplify lithological descriptions to be more amenable to analysis. My goal is to divide the litholgies into "coarse siliciclastic," "fine siliciclastic," "carbonate," and "other." Because this research compendium doubles as a package, I'll call that function from the `notfossil` package.

For a dataset this size, `simplify_lithology()` is memory intensive/slow for R. It is a lot of text manipulation, triple nested lists, tibble manipulation, and uses `tidyr::spread` internally. I've updated the major `map*()` calls to be `future_map*()` which is helping, but my laptop gets really angry.

So, because it is parallel internally, I'm going to chunk the data and then recombine after each segment is finished. The other option would be removing the parallel operations from `simplify_lithology()`, splitting the data, and then running parallel operations on those splits. I'm not sure which is actually faster. And on a machine with more RAM (e.g. my work computer), this whole split-apply-combine stuff isn't necessary, so the internal parallel seems easiest?

```{r get_lithology, cache = TRUE}

occur_collect$lith_simple <- 
  occur_collect %>%
  mutate(tile = ntile(n = 20)) %>%
  group_by(tile) %>%
  # simplify_lithology is already parallel
  group_map(~ simplify_lithology(.x$lith)) %>%
  flatten()

```

I've created a list column `lith_simple` where each element is a tibble describing the lithological composition of that unit in a simpler form. Most of the tricks above are to make it so each unit has all four lithological descriptors and that there are 0s instead of NAs when that descriptor wasn't measured.

Now that that data is all in order, we can start exploring that space. Does the average lithological composition of a geologic unit change over time? If so, how?

I'm making the lithological data into a [Atchinson composition](https://rdrr.io/cran/compositions/man/acomp.html) object of the data. This object type has convenient properties for interfacing with the `compositions` package. Once this is done, there are a lot of ways to try and summarize this data. From a math perspective, all the 0s in are dataset can cause a lot of problems, but hopefully we'll be able to skirt those for now. By coding them as 0s, though, we are explicit saying that if that lithology was present it was present in such a small amount as to be immeasurable.

I'm going to calculate mean lithology for each of the time bins we've defined to get an idea of how the average setting for fossilzation may have changed.

```{r mean_lithology}
# divide units up by bin
# then get mean lithology
bin_lith <- 
  occur_collect %>%
  arrange(desc(bin_time)) %>%
  group_by(bin_time) %>%
  filter(!duplicated(unit_id)) %>%     # no multi-counting
  ungroup() %>%
  group_by(bin_time) %>%
  group_map(~ .x %>% 
              dplyr::select(lith_simple) %>% 
              unnest() %>%
              acomp() %>%
              mean())

# what age is each value from?
bin_times_match <- 
  occur_collect %>%
  arrange(desc(bin_time)) %>%
  group_by(bin_time) %>%
  filter(!duplicated(unit_id)) %>%     # again, no multi-counting
  ungroup() %>%
  dplyr::select(bin_time) %>% 
  pull() %>%
  unique()

lith_time <- 
  reduce(bin_lith, rbind) %>%
  as_tibble() %>%
  mutate(bin_time = bin_times_match) %>%
  gather(key = key, value = value, -bin_time)

lith_time %>%
  ggplot(aes(x = bin_time, y = value, fill = key)) +
  geom_area() +
  geom_vline(data = tibble(x = big_5),
             mapping = aes(xintercept = x),
             size = 1.5,
             linetype = 'dashed') +
  scale_fill_viridis(discrete = TRUE) +
  scale_colour_viridis(discrete = TRUE) +
  scale_x_reverse() +
  labs(x = 'Time (Mya)', y = 'Percent', fill = 'Taxa')

```


We can also do a PCA of our composition data and then visualize the first two principle components, with point color corresponding to the age of that unit and point size varying by genus diversity (i.e. the number of unique genera in that unit at that time).

```{r pca_lithology, fig.width = 10, fig.height = 8}

lith_data <- 
  occur_collect %>%
  arrange(desc(bin_time)) %>%
  group_by(bin_time) %>%
  filter(!duplicated(unit_id)) %>%     # no multi-counting
  ungroup() %>%
  dplyr::select(lith_simple) %>%
  unnest() %>%
  acomp()

# princomp.acomp is really slow
# i guess no one has large compositional datasets
# ...
lith_pca <- princomp(lith_data)

# ggfortify doesn't support princomp.acomp output
# have to assemble plot by hand

# get age and diversity labels
lith_labels <- 
  occur_collect %>%
  arrange(desc(bin_time)) %>%
  group_by(bin_time, unit_id) %>%
  mutate(div = n_distinct(genus)) %>%
  ungroup() %>%
  group_by(bin_time) %>%
  filter(!duplicated(unit_id)) %>%     # no multi-counting
  ungroup() %>%
  dplyr::select(div, bin_time)


# get loadings to add to plot
lith_load <- 
  data.frame(lith_pca$loadings[1:4, 1:3]) %>%
  rownames_to_column() %>%
  as_tibble() %>%
  clean_names() %>%
  mutate(origin = 0)

# make the plot
as_tibble(lith_pca$scores) %>%
  clean_names() %>%
  mutate(time = lith_labels$bin_time,
         div = lith_labels$div) %>%
  ggplot() +
  geom_vline(xintercept = 0, linetype = 'dashed', alpha = 0.5) +
  geom_hline(yintercept = 0, linetype = 'dashed', alpha = 0.5) +
  geom_segment(data = lith_load,
               mapping = aes(x = origin, y = origin,
                             xend = comp_1,
                             yend = comp_2),
               arrow = arrow(length = unit(0.2, 'cm')),
               size = 1.5) +
  geom_text_repel(data = lith_load,
                  mapping = aes(x = comp_1, y = comp_2, label = rowname)) +
  geom_point(mapping = aes(x = comp_1, y = comp_2, colour = time, size = div)) +
  scale_colour_viridis() +
  labs(colour = 'Time (Mya)',
       size = 'Diversity',
       x = 'PC 1',
       y = 'PC 2')

```


# Lazarus-type occurrences {#lazarus}

So, technically, a **Lazarus taxon** is a taxon with a gap in its fossil record. To help better understand Lazarus taxon, I'm going to define a few features of their records. 

I'm going to define a **Lazarus occurrence** is the first occurrence of that species after a gap in their fossil record. We can further refine this to define a **Lazarus observation** as each unique geological unit, genus, time bin combination. This means that a Lazarus occurrence can be made of multiple Lazarus observations.

Similar to a Lazarus occurrence, I'm going to also define **cave occurrences**. A cave occurrence is the last occurrence of a taxon before a gap in their fossil record. I'm calling these cave occurrences because of the story of Lazarus. Lazarus went into a cave, was gone for a while, and then reappeared. 

When all of this is combined, we can then clearly state the **Lazarus effect** as when there are a multiple Lazarus occurrences at the same time. This definition means that the size of the Lazarus effect can be measured for a time bin.


## Identify Lazarus occurrences

The logic I'm using to identify Lazarus (and cave) occurrences is:

1. look at the occurrence record of each taxon (i.e. genus),
2. identify each gap,
3. identify the first occurrence after that gap,
4. mark as Lazarus occurrence.

The cave occurrences have a slightly different step 3, where I identify the last occurrence before a gap.

Here is all of that in action. And it is a mess. Something that is important to remember right now is that `bin_time` and `bin_num` *decrease* as we approach the present.

```{r get_lazarus}

# first, let's get genus occurrence over time
# i want to include the abundance of that genus in that bin in case
# i do admit that all of this is **insane**
genus_lazarus <- 
  occur_collect %>%
  # count genus occurrences
  group_by(bin_num, genus) %>%
  mutate(abundance = n()) %>%
  ungroup()  %>%
  # remove genus duplicates
  group_by(bin_num) %>%
  filter(!(duplicated(genus))) %>%
  ungroup() %>%
  arrange(bin_num) %>%                 # temporal order needed for runs
  group_by(genus) %>%                  
  # identify runs
  # thank you stackoverflow
  group_by(seq_id = cumsum(c(1, diff(bin_num) != 1))) %>%
  ungroup() %>%
  # now we want to look at genera and their runs
  group_by(genus, seq_id) %>%
  # identify all first occurrences in a run
  # identify all last occurrences in a run
  mutate(cave = if_else(bin_num == min(bin_num), 1, 0),
         lazarus = if_else(bin_num == max(bin_num), 1, 0)) %>%
  ungroup() %>%
  # FADs are not lazarus occurrences
  # LADs are not cave occurrences
  group_by(genus) %>%
  mutate(cave = if_else(bin_num == min(bin_num), 0, cave),
         lazarus = if_else(bin_num == max(bin_num), 0, lazarus)) %>%
  ungroup()

```

So that was a whirlwind, but now we have identified which occurrences are Lazarus occurrences. I've also identified all the cave occurrences.

I've specifically identified if a genus occurs before or after a gap in its record. This isn't an occurrence as defined above: that was a unique observation of a fossil. Here an occurrence is the appearance of that genus in the fossil record -- this genus can have multiple observations in that same bin.


## Lazarus occurrences over time

First, let's look at Lazarus occurrences over time. 

```{r vis_lazarus}

# got to fill in all those gaps
bins_missing <- 
  genus_lazarus %>%
  arrange(shelly) %>%
  group_by(shelly) %>%
  group_map(~ bins_all[!(bins_all %in% .x$bin_time)])

bins_fill <- 
  tibble(shelly = sort(shelly),
         bin_time = bins_missing,
         count = 0) %>%
  unnest()

lazarus_count <- 
  genus_lazarus %>%
  group_by(bin_time, shelly) %>%
  summarize(count = sum(lazarus)) %>%
  union(., bins_fill)

# count
lazarus_count %>%
  ggplot(aes(x = bin_time, y = count, fill = shelly)) +
  geom_area() +
  geom_vline(data = tibble(x = big_5),
             mapping = aes(xintercept = x),
             size = 1.5,
             linetype = 'dashed') +
  scale_fill_viridis(discrete = TRUE) +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 10)) +
  labs(x = 'Time (Mya)', y = 'Genus Lazarus occurrence', 
       fill = 'Taxa')

lazarus_count %>%
  ggplot(aes(x = bin_time, y = count, fill = shelly)) +
  geom_area(position = 'fill') +
  geom_vline(data = tibble(x = big_5),
             mapping = aes(xintercept = x),
             size = 1.5,
             linetype = 'dashed') +
  scale_fill_viridis(discrete = TRUE) +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 10)) +
  labs(x = 'Time (Mya)', y = 'Relative Lazarus occurrence', 
       fill = 'Taxa')

```

As expected there are multiple time intervals with large numbers of Lazarus occurrences, which we could consider a Lazarus effect. Interestingly, some of these intervals are not associated with the big 5 mass extinction events. Also, these patterns tend to match the patterns we observed earlier in diversity; when a group is diverse for a long time, it has more potential for gaps in the records within that group.

Now let's look at the cave occurrences. 

```{r vis_cave}

# count
cave_count <- 
  genus_lazarus %>%
  group_by(bin_time, shelly) %>%
  summarize(count = sum(cave)) %>%
  union(., bins_fill) 

cave_count %>%
  ggplot(aes(x = bin_time, y = count, fill = shelly)) +
  geom_area() +
  geom_vline(data = tibble(x = big_5),
             mapping = aes(xintercept = x),
             size = 1.5,
             linetype = 'dashed') +
  scale_fill_viridis(discrete = TRUE) +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 10)) +
  labs(x = 'Time (Mya)', y = 'Genus cave occurrence', 
       fill = 'Taxa')

cave_count %>%
  ggplot(aes(x = bin_time, y = count, fill = shelly)) +
  geom_area(position = 'fill') +
  geom_vline(data = tibble(x = big_5),
             mapping = aes(xintercept = x),
             size = 1.5,
             linetype = 'dashed') +
  scale_fill_viridis(discrete = TRUE) +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 10)) +
  labs(x = 'Time (Mya)', y = 'Relative cave occurrence', 
       fill = 'Taxa')

```

The obvious pattern here is the number of Lazarus and cave occurrences tends to increase as we approach the present. This makes sense because we're increasing in both diversity and the quality of fossil record as we approach the present.

## Percent Lazarus

The other way of looking at this would be what percent of occurrences in a time bin are Lazarus (or cave) occurrences. I'm going to compare across the taxonomic groups because that might be particularly interesting.

Wrinkle to remember: an occurrence can be both a Lazarus and a cave occurrence. There are no restrictions against this.

```{r percent_lazarus, fig.width = 10, fig.height = 10}

genus_percent <- 
  genus_lazarus %>%
  group_by(bin_time, shelly) %>%
  dplyr::summarize(lazarus_n = sum(lazarus),
                   cave_n = sum(cave),
                   total = n())

bins_missing <- 
  genus_percent %>%
  arrange(shelly) %>%
  group_by(shelly) %>%
  group_map(~ bins_all[!(bins_all %in% .x$bin_time)])

bins_fill <- 
  tibble(shelly = sort(shelly),
         bin_time = bins_missing,
         total = 0,
         lazarus_n = 0,
         cave_n = 0) %>%
  unnest()

laz_percent <- 
  genus_percent %>%
  union(., bins_fill) %>%
  mutate(normal = total - lazarus_n) %>%
  dplyr::select(-cave_n, -total) %>%
  gather(key = key, value = value, -bin_time, -shelly) %>%
  mutate(key = case_when(key == 'lazarus_n' ~ 'Lazarus',
                         key == 'normal' ~ 'Regular'))

laz_percent %>%
  ggplot(aes(x = bin_time, y = value, fill = key)) +
  geom_area() +
  geom_vline(data = tibble(x = big_5),
             mapping = aes(xintercept = x),
             size = 1.5,
             linetype = 'dashed') +
  facet_wrap(~ shelly, ncol = 2) +
  scale_fill_viridis(discrete = TRUE) +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 5)) +
  theme(legend.position = 'bottom') +
  labs(fill = 'Genus occurrence type',
       x = 'Time (Mya)', y = 'Count')

# as percents this time
laz_percent %>%
  ggplot(aes(x = bin_time, y = value, fill = key)) +
  geom_area(position = 'fill') +
  geom_vline(data = tibble(x = big_5),
             mapping = aes(xintercept = x),
             size = 1.5,
             linetype = 'dashed') +
  facet_wrap(~ shelly, ncol = 2) +
  scale_fill_viridis(discrete = TRUE) +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 5)) +
  theme(legend.position = 'bottom') +
  labs(fill = 'Genus occurrence type',
       x = 'Time (Mya)', y = 'Percent')

```

We can do the same for cave occurrences.

```{r percent_cave}

cave_percent <- 
  genus_percent %>%
  union(., bins_fill) %>%
  mutate(normal = total - cave_n) %>%
  dplyr::select(-lazarus_n, -total) %>%
  gather(key = key, value = value, -bin_time, -shelly) %>%
  mutate(key = case_when(key == 'cave_n' ~ 'Cave',
                         key == 'normal' ~ 'Regular'))

cave_percent %>%
  ggplot(aes(x = bin_time, y = value, fill = key)) +
  geom_area() +
  geom_vline(data = tibble(x = big_5),
             mapping = aes(xintercept = x),
             size = 1.5,
             linetype = 'dashed') +
  facet_wrap(~ shelly, ncol = 2) +
  scale_fill_viridis(discrete = TRUE) +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 5)) +
  theme(legend.position = 'bottom') +
  labs(fill = 'Genus occurrence type',
       x = 'Time (Mya)', y = 'Count')

# as percents this time
cave_percent %>%
  ggplot(aes(x = bin_time, y = value, fill = key)) +
  geom_area(position = 'fill') +
  geom_vline(data = tibble(x = big_5),
             mapping = aes(xintercept = x),
             size = 1.5,
             linetype = 'dashed') +
  facet_wrap(~ shelly, ncol = 2) +
  scale_fill_viridis(discrete = TRUE) +
  scale_x_reverse(breaks = scales::pretty_breaks(n = 5)) +
  theme(legend.position = 'bottom') +
  labs(fill = 'Genus occurrence type',
       x = 'Time (Mya)', y = 'Percent')

```


## Highlight PCA by Lazarus occurrences

We can also go back to the earlier PCA and now have the point size of the geological units be a function of the number of Lazarus (or cave) occurrences in that unit. We can compress our taxonomic groups because we're currently interested in those big spikes.

```{r lazarus_pca, fig.width = 10, fig.height = 8}

lazarus_sum <- 
  lazarus_count %>%
  group_by(bin_time) %>%
  dplyr::summarize(count = sum(count))

as_tibble(lith_pca$scores) %>%
  clean_names() %>%
  mutate(bin_time = lith_labels$bin_time) %>%
  left_join(., lazarus_sum, by = 'bin_time') %>%
  ggplot() +
  geom_vline(xintercept = 0, linetype = 'dashed', alpha = 0.5) +
  geom_hline(yintercept = 0, linetype = 'dashed', alpha = 0.5) +
  geom_segment(data = lith_load,
               mapping = aes(x = origin, y = origin,
                             xend = comp_1,
                             yend = comp_2),
               arrow = arrow(length = unit(0.2, 'cm')),
               size = 1.5) +
  geom_text_repel(data = lith_load,
                  mapping = aes(x = comp_1, y = comp_2, label = rowname)) +
  geom_point(mapping = aes(x = comp_1, y = comp_2, 
                           colour = bin_time, size = count)) +
  scale_colour_viridis() +
  labs(colour = 'Time (Mya)',
       size = 'Lazarus diversity',
       x = 'PC 1',
       y = 'PC 2')

```

I'm unsure if an actual pattern is really manifesting here but there are some interesting things on here. There might be something between coarse siliciclastics and the number of Lazarus occurrences.

We can do the same but using the cave occurrences.

```{r cave_pca, fig.width = 10, fig.height = 10}

cave_sum <- 
  cave_count %>%
  group_by(bin_time) %>%
  dplyr::summarize(count = sum(count))

as_tibble(lith_pca$scores) %>%
  clean_names() %>%
  mutate(bin_time = lith_labels$bin_time) %>%
  left_join(., cave_sum, by = 'bin_time') %>%
  ggplot() +
  geom_vline(xintercept = 0, linetype = 'dashed', alpha = 0.5) +
  geom_hline(yintercept = 0, linetype = 'dashed', alpha = 0.5) +
  geom_segment(data = lith_load,
               mapping = aes(x = origin, y = origin,
                             xend = comp_1,
                             yend = comp_2),
               arrow = arrow(length = unit(0.2, 'cm')),
               size = 1.5) +
  geom_text_repel(data = lith_load,
                  mapping = aes(x = comp_1, y = comp_2, label = rowname)) +
  geom_point(mapping = aes(x = comp_1, y = comp_2, 
                           colour = bin_time, size = count)) +
  scale_colour_viridis() +
  labs(colour = 'Time (Mya)',
       size = 'Cave diversity',
       x = 'PC 1',
       y = 'PC 2')

```




# TODO Modeling Lazaurus occurrences


There are $n$ observations in the data set where an observational unit is a unique genus, geological unit, time bin combination. Let's call it $y_{i}$ where $i = 1, \ldots, n$.

Predictors/covariates

- unit lithological composition (`lith`)
- taxonomic group (`shelly`)
- geological unit (`unit_id`)
- time of observation (`bin_time` or `bin_num`)
- (optional) genus identity (`genus`)

Compositional data needs to be transformed before being included as predictors in a model. This is because the data must sum to 1, which creates a non-identifiability if all parts are included as predictors. A similar problem would be having a categorical predictor and not assigning one state to the model intercept, which causes the model to effectively have 2 intercepts and a **massive** ridge in posterior density.

The standard transform for composition data to be included as a predictor in a GLM(M)/hierarchical model is the isometric log-ratio transform. DEFINE. I'm going to let the effects of these composition variables vary by taxonomic group. After all, not all taxa preserve the same but we might expect genera of the same phylum or class to have similar fossilization properties/potential.

I'm also going to have taxonomic group included as a varying-intercept, thus defining a varying-intercept and varying-slope model. As per usual with varying-intercept and varying-slope models, the covariance between all of these parameters due to taxonomic identity (some groups are more similar than others e.g. Bivalves and Brachiopods). 

There aren't a lot of different taxonomic groups in this data, so I'm going to opt for fairly tight priors for all of these parameters.

Geological unit, and time of observation can be included as non-nested varying-intercepts. Because these are

## Defining a model

## Is this a useful model?


## Preparing data for model

So we have both Lazarus occurrences and Lazarus observations, but I've technically only identified the Lazarus occurrences. 

```{r add_lazarus}

# for each individual observation of a fossil
# add in if its occurrence is during a Lazarus occurrence interval  
gen_laz <- genus_lazarus %>%
  dplyr::select(genus, bin_num, bin_time, seq_id, lazarus, cave)

occur_collect <- 
  left_join(occur_collect, gen_laz, by = c('genus', 'bin_num', 'bin_time'))

```

Now slim to unique genus, geological unit, time bin combination. Currently, genera can appear multiple times in the same unit--time bin combo. These lines in the tibble are virtually identical: same genus, same unit, same time bin, same lithological composition, same Lazarus observation state. I'm weary of double counting (or more) and I don't know if an individual-level effect is warranted.

```{r filter_unique_genus}

occur_collect <- 
  occur_collect %>%
  #group_by(genus, unit_id, bin_num) %>%
  ## abundance: count of 'identical' observations
  #mutate(abundance = n()) %>%
  #ungroup() %>%
  group_by(unit_id, bin_num) %>%
  # no double includes
  filter(!(duplicated(genus)))

```


## Defining priors


## Fitting a model


## Model adequacy




# TODO A different data--model combo

What if instead of focusing on the Lazarus occurrences, we instead focused on the presence vs absence of a genus in geological units within its observation window. For each genus, from first appearance to last appearance, identify every geological unit--time bin combination. Mark 1 present, 0 absent. Same predictors as above.

For each genus, find all the gaps in its record. Focus on temporal gaps. Identify all geological units present during those gaps. Use model posterior predictions to get posterior probability of probability of being present.

Assuming our predictors are meaningful and we have a useful model...

If we would predict something to be there based on lithology, but it isn't then that's evidence against record quality predicting individual gaps. 

If there are concentrations of periods of time where many taxa are absent but our model predicts them to be there, than that's evidence against record quality predicting mass gaps.



TO DO
