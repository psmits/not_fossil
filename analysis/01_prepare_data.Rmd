# Preparing data for analysis

The next step is to process our data so that it is ready for analysis. This process takes a lot of steps, but once it is complete we can start visualizing and modeling out data.


```{r import_raw}

#source(here::here('R', 'helper01_prepare_foo.r'))
#source(here::here('R', 'helper02_rock_process.r'))

# formerly `strat`
unit_data <- read_csv(here::here('data', 'macrostrat_units.csv'))

# formerly `fossil`
collect_data <- read_csv(here::here('data', 'macrostrat_collect.csv'))

# formerly `taxon
pbdb_data <- read_csv(here::here('data', 'pbdb_occurrences.csv'))

```

There are several useful constants that will appear throughout the next few sections.

```{r constants}

# useful constants
constant <- 20
shelly <- c('Brachiopoda', 'Anthozoa', 'Trilobita', 
            'Bivalvia', 'Gastropoda')#, 'Cephalopoda')
temp_range <- c(485.4, 419.2)          # ordovicain + silurian
hirnantian <- 445.6

```

Now that that's out of the way, let's start getting out data into shape. An obvious first step is connect the Macrostrat units table to the fossils table. 

There are multiple collections occurrences per unit, so I'll add all the appropriate unit information to each fossil collection. I'm not worrying about units that lack fossils (yet), hence the left join. 

```{r join_macrostrat}

collect_unit <- left_join(x = collect_data, y = unit_data, 
                         by = c('unit_id', 'col_id', 't_age', 'b_age')) %>%
  dplyr::select(-(genus_no:taxon_no), refs.y) # redundant/unnecessary

print(collect_unit)

```

This gives a single table with all fossil collections associated with their geological information (lithology, age, etc.) The next step is associating the geological context of each collection with the individual occurrences within that collection. I'm only caring about occurrences recorded in the PBDB -- they have the most information -- hence the left join. I'm also going to filter the occurrences to just those of shelly marine taxa which I defined above as one of the useful constants.

```{r join_pbdb}

occur_collect <- 
  pbdb_data %>%
  filter(phylum %in% shelly | class %in% shelly) %>%
  left_join(., collect_unit, by = c('collection_no' = 'cltn_id')) %>%
  mutate(occur_mid_ma = (max_ma + min_ma) / 2,
         unit_mid_ma = (t_age + b_age) / 2)

```

A big issue is that these occurrences from all over time, not just the Ordovician + Silurian. Just look.



```{r vis_ages}

occur_collect %>%
  ggplot(aes(x = occur_mid_ma)) +
  geom_bar(size = 2)

```

This problem due to geological units not being restricted to a particular time interval. A unit can range through, into, or out of our target temporal range.

To overcome this and focus only on fossil occurrences from the Ordovician or Silurian, I filtering down to only those occurrences who's mid-point age is within `temp_range`.

```{r filter_age}

occur_collect <- 
  occur_collect %>%
  filter(between(occur_mid_ma, temp_range[2], temp_range[1]))

occur_collect %>%
  ggplot(aes(x = occur_mid_ma)) +
  geom_bar(size = 2)

```

Much better.








```{r}




# bin data
# figure out logical breaks
ra <- range(strat$m_age)
timerange <- abs(diff(ra))
#timerange <- abs(diff(ord))
rr <- timerange / constant
brks1 <- seq(from = hirnantian, to = ra[2] + 1, by = rr) # 
brks2 <- seq(from = hirnantian, to = ra[1] - 1, by = -rr) # 
brks <- c(rev(brks2[-1]), brks1)
brks <- cbind(brks[-1], brks[-length(brks)])
brks <- brks[rev(seq(nrow(brks))), ]
write_rds(brks, path = '../data/breaks.rds')

# one pesky observation that doesn't play nice with bins
strat <- strat[strat$m_age > min(brks), ]


# get the count information from the data
out <- purrr::map(shelly, ~ get_values(taxon, strat, .x))
names(out) <- shelly


# make a mollusc category after the fact
tt <- full_join(out$Bivalvia, out$Gastropoda)
tt <- tt %>%
  group_by(unit_id, bin) %>%
  dplyr::mutate(diversity = sum(diversity),
                collections = sum(collections)) %>%
  ungroup() %>%
  distinct(unit_id, .keep_all = TRUE)
out$Mollusca <- tt
shelly <- names(out)

out <- purrr::map(out, function(x) {
                    m <- x$unit_id != 19112
                    x <- x[m, ]
                    x})

# do all the exporting
# partials make this easier, imo
esd <- partial(export_standata, type = 'diversity')
purrr::walk2(out, shelly, esd)
eso <- partial(export_standata, type = 'occurrence')
purrr::walk2(out, shelly, eso)

```
